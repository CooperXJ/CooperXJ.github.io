<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cooperxj.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录一些学习笔记、小说、随笔">
<meta property="og:type" content="website">
<meta property="og:title" content="Cooper Notes">
<meta property="og:url" content="http://cooperxj.github.io/page/31/index.html">
<meta property="og:site_name" content="Cooper Notes">
<meta property="og:description" content="记录一些学习笔记、小说、随笔">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cooper">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cooperxj.github.io/page/31/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Cooper Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cooper Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">obey rules</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">集群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:00:30" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E9%9B%86%E7%BE%A4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E9%9B%86%E7%BE%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点组成集群命令"><a href="#节点组成集群命令" class="headerlink" title="节点组成集群命令"></a>节点组成集群命令</h3><p>各个节点服务器需要将cluster-enabled配置选项配置为yes开启集群模式</p>
<p><code>cluster meet &lt;ip&gt; &lt;port&gt;</code></p>
<h4 id="meet命令的实现"><a href="#meet命令的实现" class="headerlink" title="meet命令的实现"></a>meet命令的实现</h4><p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210913102818.png" alt="image-20210913102817330"></p>
<p>三次沟通之后双方都为彼此创建了对应的clusterNode结构</p>
<p>最后结点A会通过Gossip协议将B的信息传递给集群中的其他结点</p>
<h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><h4 id="clusterNode"><a href="#clusterNode" class="headerlink" title="clusterNode"></a>clusterNode</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p>节点的创建时间</p>
</li>
<li><p>名字</p>
</li>
<li><p>当前配置纪元</p>
</li>
<li><p>ip</p>
</li>
<li><p>端口号</p>
</li>
<li><p>flag</p>
<p>节点标识（主要包括节点的主从状态、是否上下线状态）</p>
</li>
<li><p>保存连接节点所需要的有关信息</p>
<p>clusterLink *link</p>
</li>
</ul>
<h4 id="clusterLink"><a href="#clusterLink" class="headerlink" title="clusterLink"></a>clusterLink</h4><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><ul>
<li>连接的创建时间</li>
<li>套接字描述符</li>
<li>输出缓冲区（发送）</li>
<li>输入缓冲区（接受）</li>
<li>与该连接相关联的结点</li>
</ul>
<h4 id="clusterStat"><a href="#clusterStat" class="headerlink" title="clusterStat"></a>clusterStat</h4><p>每个节点都会保存一个该结构</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p>myself</p>
<p>指向当前结点的指针</p>
</li>
<li><p>当前配置的纪元</p>
</li>
<li><p>集群当前状态（在线还是下线）</p>
</li>
<li><p>处理槽的数量</p>
</li>
<li><p>集群结点的名单（包括myself）数据结构是一个字典</p>
<p>key为结点的名字，val为对应的clusterNode结构</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210913102646.png" alt="image-20210913102644496"></p>
</li>
</ul>
<h2 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li><p>集群的整个数据库被分为16384个槽，数据库中的每个键都属于整个16384个槽中的其中一个，集群中的每个节点可以处理0~16384个槽</p>
</li>
<li><p>如果0~16384个槽都有对应的结点得到处理，那么集群处于上线状态，如果任何一个槽没有得到处理，那么集群处于下线状态</p>
</li>
<li><p>命令</p>
<p><code>cluster addslots &#123;槽id...&#125;</code></p>
</li>
</ul>
<h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p>clusterNode中有两个属性与其有关</p>
<ul>
<li>slots数组</li>
<li>numslots 槽的数量</li>
</ul>
<p>这些槽是以二进制位进行标号，类似于状态压缩一样，每一个二进制位为1代表当前槽被当前节点处理，为0则表示不被当前节点处理</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210913104835.png" alt="image-20210913104834346"></p>
<p>对于程序来说检查当前节点是否处理某个槽或者将某个槽分配给当前节点的时间复杂度都是O(1),因为只需要对二进制位操作即可</p>
<h3 id="传播槽信息"><a href="#传播槽信息" class="headerlink" title="传播槽信息"></a>传播槽信息</h3><p>当前节点除了会记录自己的槽信息之外，还会自己的slots数组发送给集群中的其他结点</p>
<h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息</p>
<p>slots数组中的每一项都指向一个clusterNode结点，表示该槽已经指派给了clusterNode结构所代表的结点</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210913105747.png" alt="image-20210913105746538"></p>
<p><font color=red>注意：clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots只记录了clusterNode结构所代表的结点的槽指派信息</font></p>
<h3 id="addslots命令的实现"><a href="#addslots命令的实现" class="headerlink" title="addslots命令的实现"></a>addslots命令的实现</h3><p>当结点接受该命令时会通过clusterState结构中的slots数组检查当前槽是否有对应的clusterNode结点，如果有则表示已经当前槽被分配了结点，否则则执行分配操作，执行完毕之后会发送消息告知集群中的其他结点自己目前正在负责哪些槽</p>
<h2 id="集群中执行命令"><a href="#集群中执行命令" class="headerlink" title="集群中执行命令"></a>集群中执行命令</h2><p>当客户端发送与数据库键相关的指令时，接受命令的结点会计算出命令要处理的数据库键属于哪个槽，并检查该槽是否指派给了自己</p>
<ul>
<li>如果该键所在的槽正好在当前节点上，则直接执行</li>
<li>如果不在，则返回一个moved命令，并指引客户端转向至正确的结点并在此发送之前执行的命令</li>
</ul>
<h3 id="计算属于哪个槽"><a href="#计算属于哪个槽" class="headerlink" title="计算属于哪个槽"></a>计算属于哪个槽</h3><p>CRC16(key)&amp;16383</p>
<h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><ul>
<li><p>节点数据库与单机数据库的区别之一：节点只能使用0号数据库</p>
</li>
<li><p>节点会使用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系</p>
<p>跳跃表中的每个节点的分值都是一个槽号，每个节点的成员都是一个数据库键</p>
<p>这样的好处在于可以对数据某个或者某个槽的所有数据库键进行批量操作，例如返回count个数据槽slot的数据库键</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210913111715.png" alt="img" style="zoom:80%;" />





<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>redis集群的重新分片可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点</p>
<p>重新分片对源节点和目标节点上的其他正常操作没有影响</p>
<h3 id="重新分片原理"><a href="#重新分片原理" class="headerlink" title="重新分片原理"></a>重新分片原理</h3><p>重新分片步骤如下：</p>
<ol>
<li>redis-trib对目标节点发送信息并让目标节点准备好从源节点导入属于槽slot的键值对</li>
<li>redis-trib对源节点发送信息并让源节点准备好属于槽slot的键值对迁移至目标节点</li>
<li>redis-trib向目标节点发送<code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code>命令，最多获得count个属于槽slot的键值对的键名</li>
<li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个命令，将被选中的键原子地从源节点迁移至目标节点</li>
<li>重复3、4步骤</li>
<li>redis-trib向集群中的任意一个节点发送消息，将槽slot指派给目标节点，该消息会发送给集群中的每个节点，最终集群中的每个节点都会知道槽slot已经指派给了目标节点</li>
</ol>
<h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><h3 id="错误发送的情况"><a href="#错误发送的情况" class="headerlink" title="错误发送的情况"></a>错误发送的情况</h3><p>在进行重新分片的期间，源节点向目标节点迁移一个槽的过程中，有一份数据在源节点的槽中，还有一部分数据在目标节点的槽中。</p>
<p>因此当客户端针对该槽中数据的查询会最多经过两个步骤</p>
<ol>
<li>源节点在自己的槽中查找指定的键，如果找到的话就执行相应的命令</li>
<li>源节点没有能够在自己的槽中找到指定的键，源节点会向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点并再次发送之前想要执行的命令</li>
</ol>
<h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>当某个槽所包含的各个键分散在节点 A 和节点 B 中， 客户端在节点 A 中没找到某个键时， 它应该转向到节点 B 中去寻找， 但是这种转向应该仅仅影响一次命令查询， 而不是让客户端每次都直接去查找节点 B ： 在节点 A 所持有的属于该槽的键没有全部被迁移到节点 B 之前， 客户端应该先访问节点 A ， 然后再访问节点 B 。</p>
<p>只有先执行了ASKING命令才会使得客户端在B节点访问该槽时执行命令，否则将会返回moved的错误。</p>
<p>因为上述原因， 如果我们要在查找节点 A 之后， 继续查找节点 B ， 那么客户端在向节点 B 发送命令请求之前， 应该先发送一个 <code>ASKING</code> 命令， 否则这个针对带有 <code>IMPORTING</code> 状态的槽的命令请求将被节点 B 拒绝执行。因为此时B节点并不拥有该槽，A节点仍然是该槽的拥有者，所以不加ASKING命令的话B节点会拒绝执行命令。</p>
<p>注意：ASKING命令是一次性的，用完就生效了。</p>
<h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>集群中的各个节点都可以对其进行设置从节点，用来复制自身的数据</p>
<p>命令为：<code>cluster replicate &lt;node_id&gt;</code></p>
<p>clusterNode结构中的salveof属性会指向一个clusterNode，表示当前节点的主节点</p>
<p>clusterNode结构中的slaves属性会指向一个clusterNode数组，表示当前节点的从节点数组</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点都会定期向集群中的其他结点发送PING命令，检测对方是否在线。</p>
<p>如果接受ping消息的结点没有在规定时间内返回pong消息，那么发送ping消息的结点就会将目标节点标识为疑似下线</p>
<p>集群中的各个主节点通过消息交换，超过半数以上的主节点得知某个主节点的疑似下线，那么该主节点就会被标记为已下线，并且第一个发现该主节点下线的结点将发送一条该主节点标记为下线的消息，并在集群进行广播，所有收到消息的结点会将该主结点标记为已下线</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己正在复制的主节点已经进入下线状态，从节点将开始对下线结点进行故障转移，具体步骤如下：</p>
<ol>
<li><p>从已下线的主节点的从节点中选中一个</p>
<p>选举方法和Sentinel那边差不多</p>
</li>
<li><p>被选中的从节点执行slave of no one命令使其成为新的主节点</p>
</li>
<li><p>新的主节点会撤销所有已下线主节点的槽指派，并将这些槽指派给自己</p>
</li>
<li><p>新的主节点广播消息，告诉其他人我已经成为主节点并负责哪些槽</p>
</li>
</ol>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>集群中的结点通过发送和接受消息来进行通信</p>
<p>常见的消息包括以下五种：</p>
<ul>
<li><p>meet</p>
<p>请求加入到集群中</p>
</li>
<li><p>ping</p>
<p>健康检测</p>
</li>
<li><p>pong</p>
<p>回应消息或者广播自己的pong消息让集群中的其他结点立即刷新这个结点的认识</p>
</li>
<li><p>fall （为了满足及时性，使用广播的方式）</p>
<p>下线</p>
</li>
<li><p>publish</p>
<p>当集群中的一个节点接收到一个publish命令，节点会执行这个命令并向集群广播该命令，接收到该消息的其他结点也会执行相同的命令</p>
</li>
</ul>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">redis数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:01:46" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E5%BA%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><h3 id="redisServer"><a href="#redisServer" class="headerlink" title="redisServer"></a>redisServer</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p>db （redisDb *）</p>
<p>保存服务器中的所有数据库，是一个数组</p>
</li>
<li><p>dbnum (int)</p>
<p>服务器中的数据库数量（默认为16个）</p>
<ul>
<li><p>切换数据库</p>
<p><code>select &#123;id&#125;</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="redisClient"><a href="#redisClient" class="headerlink" title="redisClient"></a>redisClient</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p>db （redisDb *）</p>
<p>记录当前客户端正在使用的数据库</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210902104349.png" alt="image-20210902104344167"></p>
</li>
</ul>
<p><font color=red>注意：当程序中需要切换数据库的时候，一定要记得显示的切换数据库</font></p>
<h3 id="redisDb"><a href="#redisDb" class="headerlink" title="redisDb"></a>redisDb</h3><h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p>dict （*dict）</p>
<p>数据库键空间，保存着数据库中的所有键值对</p>
</li>
<li><p>expires （*dict）</p>
<p>过期字典，保存着键和其对应的过期时间</p>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="设置键的过期时间"><a href="#设置键的过期时间" class="headerlink" title="设置键的过期时间"></a>设置键的过期时间</h4><ul>
<li><p>命令</p>
<ul>
<li><p>以s为单位</p>
<ul>
<li><p><code>expire &#123;key&#125; &#123;time&#125;</code> </p>
</li>
<li><p><code>expireat &#123;key&#125; &#123;timestamp&#125;</code> </p>
</li>
</ul>
</li>
<li><p>以ms为单位</p>
<ul>
<li><code>pexpire &#123;key&#125; &#123;time&#125;</code></li>
<li><code>pexpireat &#123;key&#125; &#123;timestamp&#125;</code></li>
</ul>
</li>
<li><p>set和expire同时执行，只针对字符串有效</p>
<ul>
<li><code>setex &#123;key&#125; &#123;time&#125; &#123;value&#125;</code></li>
</ul>
</li>
</ul>
<p> <strong>以上所有的命令都会转为pexpireat</strong></p>
</li>
</ul>
<h4 id="查看生存时间"><a href="#查看生存时间" class="headerlink" title="查看生存时间"></a>查看生存时间</h4><ul>
<li><p>以s为单位</p>
<p><code>ttl &#123;key&#125;</code></p>
</li>
<li><p>以ms为单位</p>
<p><code>pttl &#123;key&#125;</code></p>
</li>
</ul>
<h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>功能：在过期字典中查找给定的键并解除键和值（过期时间）在过期字典中的关联</p>
<p><font color=red>注意：此命令的键必须在键未过期之前使用</font></p>
<p>命令</p>
<p><code>persist &#123;key&#125;</code></p>
<h3 id="过期键的策略"><a href="#过期键的策略" class="headerlink" title="过期键的策略"></a>过期键的策略</h3><h4 id="定时策略"><a href="#定时策略" class="headerlink" title="定时策略"></a>定时策略</h4><p>在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>不管键的过期时间，过期之后只有被查询到了才会被删除</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间，对数据库进行一次检查删除里面的过期键。每次删除多少个过期键以及检查多少个数据库由算法决定</p>
<h4 id="redis的策略"><a href="#redis的策略" class="headerlink" title="redis的策略"></a>redis的策略</h4><p>配合使用惰性删除和定期删除策略</p>
<h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><ul>
<li><p>生成RDB阶段</p>
<p>对于已过期的键不会被保存到新创建的RDB文件中</p>
</li>
<li><p>载入EDB文件阶段</p>
<ul>
<li><p>主服务器</p>
<p>对于过期的键会自动忽略</p>
</li>
<li><p>从服务器</p>
<p>过期和未过期键一视同仁</p>
<p>主从进行同步的时候会对过期键进行清空</p>
</li>
</ul>
</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><ul>
<li><p>写入阶段</p>
<p>当过期键过期时，会向AOF文件追加一条del命令</p>
</li>
<li><p>生成阶段</p>
<p>对于过期的键会自动忽略</p>
</li>
</ul>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式下，从服务器的过期键删除操作由主服务器控制</p>
<ul>
<li>当主服务器在删除一个过期键之后，会显式地向从服务器发生del命令</li>
<li>从服务器在执行客户端的读命令时及时碰到过期键也不会删除，而是像处理未过期的键一样来处理过期键</li>
<li>从服务器只有在接到主服务器的del命令才会删除过期键</li>
</ul>
<h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li><p>该功能只有在2.8版本及其之后才有</p>
</li>
<li><p>需要开启config set notify-keyspace-events KEA （KEA表示发送所有类型的通知）</p>
<p>具体参见</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>发送的通知</th>
</tr>
</thead>
<tbody><tr>
<td><code>K</code></td>
<td>键空间通知，所有通知以 <code>__keyspace@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td><code>E</code></td>
<td>键事件通知，所有通知以 <code>__keyevent@&lt;db&gt;__</code> 为前缀</td>
</tr>
<tr>
<td><code>g</code></td>
<td><code>DEL</code> 、 <code>EXPIRE</code> 、 <code>RENAME</code> 等类型无关的通用命令的通知</td>
</tr>
<tr>
<td><code>$</code></td>
<td>字符串命令的通知</td>
</tr>
<tr>
<td><code>l</code></td>
<td>列表命令的通知</td>
</tr>
<tr>
<td><code>s</code></td>
<td>集合命令的通知</td>
</tr>
<tr>
<td><code>h</code></td>
<td>哈希命令的通知</td>
</tr>
<tr>
<td><code>z</code></td>
<td>有序集合命令的通知</td>
</tr>
<tr>
<td><code>x</code></td>
<td>过期事件：每当有过期键被删除时发送</td>
</tr>
<tr>
<td><code>e</code></td>
<td>驱逐(evict)事件：每当有键因为 <code>maxmemory</code> 政策而被删除时发送</td>
</tr>
<tr>
<td><code>A</code></td>
<td>参数 <code>g$lshzxe</code> 的别名</td>
</tr>
</tbody></table>
<p>输入的参数中至少要有一个 <code>K</code> 或者 <code>E</code> ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。</p>
<p>举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 <code>Kl</code> ， 诸如此类。</p>
<p>将参数设为字符串 <code>&quot;AKE&quot;</code> 表示发送所有类型的通知。</p>
</li>
<li><p><font color=red>注意：以下所有操作对于get不生效</font></p>
</li>
</ul>
<h4 id="键空间通知"><a href="#键空间通知" class="headerlink" title="键空间通知"></a>键空间通知</h4><p>某个键执行了什么命令</p>
<ul>
<li><p>命令</p>
<ul>
<li><p>单个键</p>
<p><code>subscribe __keyspace@&#123;id&#125;__:&#123;keyname&#125;</code></p>
<p>id: 数据库的编号</p>
<p>keyname：键</p>
<p><code>subscribe __keyspace@0__:space</code></p>
<p>表示获取0号数据库中针对message键执行的所有命令</p>
</li>
<li><p>所有键</p>
<p><code>psubscribe __keyspace@&#123;id&#125;__:&#123;keyname pattern&#125;</code></p>
<p><code>psubscribe __keyspace@0__:space*</code></p>
<p>表示获取0号数据库中针对message开头的所有键执行的所有命令</p>
</li>
</ul>
</li>
</ul>
<h4 id="键事件通知"><a href="#键事件通知" class="headerlink" title="键事件通知"></a>键事件通知</h4><p>某个命令被哪个键执行了</p>
<ul>
<li><p>命令</p>
<ul>
<li><p>单个键</p>
<p><code>subscribe __keyevent@&#123;id&#125;__:&#123;operation&#125;</code></p>
<p>id: 数据库的编号</p>
<p>keyname：键</p>
<p><code>subscribe __keyevent@0__:del</code></p>
<p>表示获取0号数据库中所有执行del操作的键</p>
</li>
<li><p>所有键</p>
<p><code>psubscribe __keyevent@&#123;id&#125;__:&#123;operation pattern&#125;</code></p>
<p><code>psubscribe __keyevent@0__:*</code></p>
<p>表示获取0号数据库中所有执行所有操作（不包括get）的键</p>
</li>
</ul>
</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol>
<li>检查是否符合给定的通知类型，也就是准备中定义的类型</li>
<li>检查是否允许发送键空间通知</li>
<li>检查是否允许发生键事件通知</li>
</ol>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:01:03" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E4%BA%8B%E5%8A%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E4%BA%8B%E5%8A%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>622</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ul>
<li><p>命令</p>
<p><code>multi</code></p>
</li>
</ul>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>开启时候之后所有的命令都会以一个FIFO的队列形式进行保存</p>
<h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>每个redis<strong>客户端</strong>都有自己的事务状态，该状态保存在客户端状态的mstate属性中</p>
<p>该属性是一个事务队列包含以下两个部分</p>
<ul>
<li>commands （multiCmd*） 事务队列</li>
<li>队列长度</li>
</ul>
<p>multiCmd的结构如下</p>
<ul>
<li>参数</li>
<li>参数数量</li>
<li>命令指针</li>
</ul>
<img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210916104547.png" alt="img" style="zoom:50%;" />



<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><ul>
<li><p>命令</p>
<p><code>exec</code></p>
</li>
</ul>
<p>按照事务的顺序（先进先出）进行执行</p>
<p>如果其中有错误的命令（比如指令不存在这种）就会直接在进入队列时报错，但是其他事务只有在出队执行时才会发现错误</p>
<h3 id="watch的实现"><a href="#watch的实现" class="headerlink" title="watch的实现"></a>watch的实现</h3><p>watch一般与multi搭配使用</p>
<p>watch是一个乐观锁，他可以在exec命令执行之前，监视任意数量的数据库键，并在执行exec命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话服务器将拒绝执行。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在redis<strong>数据库</strong>中都保存着一个watched_keys字典，这个字典的键是某个被watch命令监视的数据库键，字典值是一个链表，记录了所有监视该键的客户端</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210916105249.jpeg" alt="img"></p>
<p>如果有客户端对被监视的键进行了修改，那么会打开客户端的redis_dirty_cas标识，表示该客户端的事务安全性已经被破坏</p>
<p>比如有2个客户端在监视msg键，并且已经watch与此同时开启了事务，但是在前两个客户端执行的过程中有一个客户端在此期间set msg了，那么前两个客户端的redis_dirty_key就会被打开，两个客户端再执行对msg的操作就会被拒绝</p>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:00:15" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E5%A4%8D%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E5%A4%8D%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>在redis中用户可以通过slaveof命令让一个服务器去复制另一个服务器</p>
<p><font color=red>需要注意的是：在docker中直接启动redis是单机模式，即使输入了slaveof也无法生效，需要使用集群方式启动才会生效</font></p>
<h2 id="旧版复制功能"><a href="#旧版复制功能" class="headerlink" title="旧版复制功能"></a>旧版复制功能</h2><p>旧版的复制功能主要包含以下两个步骤</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向服务器发送slaveof命令后，要求从服务器复制主服务器时，从服务器需要执行同步操作，将从服务器的状态更新至主服务器当前所处的数据库状态</p>
<p>步骤如下：</p>
<ol>
<li>从服务器向主服务器发送SYNC命令</li>
<li>收到命令后主服务器执行BGSAVE命令，在后台生成RDB文件并使用一个缓冲区记录从现在开始执行的所有写命令</li>
<li>当主服务器的BGSAVE执行完毕时，主服务器会将生成的RDB文件发送给从服务器，从服务器接受该文件后会载入该RDB文件</li>
<li>主服务器将缓冲区中所有写命令发送给从服务器，从服务器执行命令将自己的状态与主服务器保持一致</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>当同步操作执行完毕之后，主服务器会将自己的写命令同步传播给从服务器，从而使得两者状态保持一致</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>当从服务器与主服务器发送短线之后，主服务器又会生成RDB文件发送给从服务器，包括从服务器已经拥有的键值对，完全就是重新执行一遍同步操作，之前的就全部作废了。</p>
<h2 id="新版复制功能"><a href="#新版复制功能" class="headerlink" title="新版复制功能"></a>新版复制功能</h2><h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><p>新版将SYNC改为了PSYNC</p>
<ul>
<li><p>如果是从服务器第一次与主服务器进行连接，那么会执行一次完整的同步步骤</p>
</li>
<li><p>如果是部分同步之后发生了短线，如果条件允许，主服务器只需要将<font color=red>断线期间的写命令发生给从服务器即可</font>，不需要重新执行一次完整的同步操作</p>
</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>复制偏移量</p>
<p>主服务器和从服务器会分别维护一个复制偏移量，通过每次对比主从之前的偏移量就可以知道当前主从服务器之间相差哪些数据</p>
</li>
<li><p>主服务器的复制积压缓冲区</p>
<p>该缓冲区由主服务器进行维护，是一个固定长度的先进先出的队列，默认大小为1MB</p>
<p>如果偏移量之后的数据依旧存在于复制挤压缓冲区，那么主服务器就会对从服务器执行部分重同步操作，否则将会执行完整的重同步操作</p>
<p>一般挤压缓冲区的大小 = second*write_size_per_second来进行估算</p>
</li>
<li><p>服务器运行ID</p>
<p>每个redis主从服务器都会有自己的运行ID，根据ID来判断是否该从服务器是之前连接过主服务器</p>
</li>
</ul>
<h4 id="PSYNC的实现"><a href="#PSYNC的实现" class="headerlink" title="PSYNC的实现"></a>PSYNC的实现</h4><h5 id="从服务器"><a href="#从服务器" class="headerlink" title="从服务器"></a>从服务器</h5><ul>
<li><p>第一次复制</p>
<p>发送 PSYNC ？ -1</p>
</li>
<li><p>复制以后但是断线之后</p>
<p>PSYNC <runid> <offset></p>
</li>
</ul>
<h5 id="主服务器"><a href="#主服务器" class="headerlink" title="主服务器"></a>主服务器</h5><ul>
<li><p>返回++FULLRESYNC <runid> <offset></p>
<p>表示主服务器与从服务器执行完整的同步操作</p>
</li>
<li><p>返回++CONTINUE</p>
<p>表示执行部分同步操作</p>
</li>
<li><p>返回-ERR</p>
<p>表示从服务器的版本低于Redis2.8，识别不了PSYNC命令，将会执行完整的同步操作</p>
</li>
</ul>
<h4 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h4><ol>
<li><p>设置主服务器的地址和端口</p>
<p>执行了slaveof命令之后，从服务器将会保存主服务器的地址和端口</p>
</li>
<li><p>建立套接字连接</p>
</li>
<li><p>发送ping命令</p>
</li>
<li><p>身份验证</p>
<p>需要注意的是主从服务器要么都设置密码，要么都不设置，如果都设置了密码需要主从服务器端密码相同</p>
</li>
<li><p>发送端口信息</p>
<p>从服务器向主服务器执行replconf listening-port <port-number>，向主服务器发送从服务器的监听端口号，主服务器接收到该命令之后会在从服务器所对应的客户端状态的slave_listening_port属性中记录该端口号</p>
</li>
<li><p>同步</p>
</li>
<li><p>命令传播</p>
</li>
<li><p>心跳检测</p>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务发送命令：</p>
<p>replconf ack <replication_offset>,其中replication_offset是从服务器当前的复制偏移量</p>
<p>主要有以下三个作用</p>
<ul>
<li><p>检测主从服务器的网络连接状态</p>
</li>
<li><p>辅助实现min-slaves选项</p>
</li>
<li><p>检测命令丢失</p>
<p>如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么从服务器在发送该命令时，主服务器会检测到并将对应在复制缓冲区总的数据重新发送给从服务器</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">redis数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:01:38" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>len （int） 记录当前已经使用字节的长度</li>
<li>free（int）记录当前buf数组中未使用字节的数量</li>
<li>buf[] (char) 字节数组，保存字符串（<font color=red>因为不仅仅保存的是字符串，有时候也会保存二进制数据，因此成为字节数组</font>）</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>可以在O(1)时间复杂度内统计字符串的长度</p>
</li>
<li><p>可以避免缓冲区的溢出，因为常见的C中的字符串函数比如strcat(char *dest,char *src)需要用户保证dest有足够的空间，否则会缓冲区溢出。但是SDS会先检查空间是否满足，如果不满足会根据一定的策略进行扩充空间</p>
<ul>
<li><p>对应分配策略</p>
<p>如果每次拼接字符串的操作都分配空间的话会比较耗时，因此这里采用了两种优化策略</p>
<ul>
<li><p>空间预分配</p>
<ul>
<li><p>修改之后SDS的长度&lt;1MB</p>
<p>分配2*len(修改之后的SDS)+1 （+1是为了保存’\0’）</p>
</li>
<li><p>修改之后SDS的长度&gt;=1MB</p>
<p>除了分配满足修改之后的SDS的空间，会额外分配一个1MB的未使用空间+1（+1是为了保存’\0’）</p>
</li>
</ul>
</li>
<li><p>惰性空间释放</p>
<p>当SDS需要缩短字符串时，不会收回当前SDS所占的空间中不需要的空间，而是使用free属性将这些空闲的空间记录下来，下次再使用</p>
</li>
</ul>
<p><font color=red>SDS有自己的API，比如sdscat,这些都是针对sds本身的API来说的</font></p>
</li>
</ul>
</li>
<li><p>二进制安全</p>
<p>在C语言中字符串只能存放文本数据，因为二进制数据会被分割（例如出现’\0’就会认为是一句话的结束），但是SDS会原封不动的保留所存放的字符串，不会对特殊字符进行任何限制、过滤。</p>
<p>因为SDS不是通过’\0’判断字符串是否结束，而是通过len属性来判断</p>
</li>
<li><p>兼容了C语言字符串的函数，常见的例如strcat，strcasecmp都可以使用</p>
<p>strcat(c_string,sds-&gt;buf)</p>
<p>strcasecmp(c_string,sds-&gt;buf)</p>
</li>
</ul>
<h4 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h4><h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><ul>
<li><p>int</p>
<p>如果字符串对象保存的是整数数值，并且这个整数数值可以使用long类型来表示，那么该字符串对象的编码为int</p>
<p><strong>double类型会保存为字符串类型</strong></p>
</li>
<li><p>embstr</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度&lt;=39字节，那么这个字符串对象将使用embstr编码方式保存这个字符串值</p>
</li>
<li><p>raw</p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度&gt;39字节，那么这个字符串对象将使用raw编码方式保存这个字符串值</p>
</li>
</ul>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li><p>embstr通过调用一次内存分配函数来创建redisObject结构和sdshdr结构，但是raw会调用两次内存分配函数</p>
</li>
<li><p>释放embstr的字符串对象只需要调用一次内存释放函数，raw需要两次</p>
</li>
<li><p>embstr的字符串对象都保存在一块连续的内存中，可以更好利用缓存带来的优势</p>
</li>
</ul>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><ul>
<li>int类型如果被执行命令之后变为了字符串，那么会成为raw类型</li>
<li><font color=red>embstr类型只有只读属性，如果被修改了会变成raw编码类型</font></li>
</ul>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="编码类型-1"><a href="#编码类型-1" class="headerlink" title="编码类型"></a>编码类型</h4><h5 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h5><ul>
<li><p>ziplist</p>
<p>压缩链表</p>
</li>
<li><p>linkedlist</p>
<p>双向链表</p>
</li>
</ul>
<h5 id="转换-1"><a href="#转换-1" class="headerlink" title="转换"></a>转换</h5><p>当以下2个条件都满足时</p>
<ul>
<li><p>列表保存到所有字符串元素长度&lt;64字节</p>
</li>
<li><p>列表对象保存的元素数量&lt;512个</p>
</li>
</ul>
<p>会使用ziplist编码</p>
<p>否则会使用linkedlist编码</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>在元素较少时，ziplist可以更好的节约内存，并且是以连续块方式保存的压缩列表比起双端链表可以更快地载入到缓存中</p>
<h4 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h4><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><ul>
<li>Node<ul>
<li>listNode * prve</li>
<li>listNode * next</li>
<li>void * value</li>
</ul>
</li>
<li>list<ul>
<li>listNode *head</li>
<li>listNode *tail</li>
<li>long len</li>
<li>dup （节点复制函数）</li>
<li>free （节点释放值函数）</li>
<li>match （节点值比较函数）</li>
</ul>
</li>
</ul>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>双端无环，可以在O(1)时间内找到头结点和尾结点</li>
<li>自带计数器，可以在O(1)时间内找到长度</li>
<li>多台，使用void *指针存放节点值，可以保存不同类型的值</li>
</ul>
<h4 id="ziplist（压缩列表）"><a href="#ziplist（压缩列表）" class="headerlink" title="ziplist（压缩列表）"></a>ziplist（压缩列表）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现</li>
<li>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做哈希键的底层实现</li>
</ul>
<h5 id="压缩节点"><a href="#压缩节点" class="headerlink" title="压缩节点"></a>压缩节点</h5><h6 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h6><ul>
<li><p>previous_entry_length</p>
<p>记录压缩列表中前一个节点的长度</p>
<p>以字节为单位</p>
<ul>
<li>如果前一个节点的长度&lt;254则使用一个字节表示</li>
<li>如果前一个节点的长度&gt;=254则使用5个字节表示</li>
</ul>
<p><strong>好处：可以通过该属性达到从后向前遍历的目的</strong></p>
<p><font color=red>注意点：插入或者删除节点，有可能引起连锁更新，也就是这个属性的长度会随着操作而发生变化，但是整体影响不大</font></p>
</li>
<li><p>encoding</p>
<p>记录节点的content属性所保存的类型以及长度</p>
<ul>
<li>一字节、两字节或者五字节长，值的最高位为00，01或者10的是字节数组编码，表示content属性保存着字节数组，数组的长度为编码除去最高两位之后的其他记录</li>
<li>一个字节长，值的最高位以11开头的是整数编码，表示content属性保存的是整数值，整数的类型和长度为编码除去最高两位之后的其他记录</li>
</ul>
</li>
<li><p>content</p>
<p>保存节点的值</p>
</li>
</ul>
<h5 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h5><h6 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h6><ul>
<li><p>zlbytes （unit32_t）</p>
<p>记录压缩列表占用的内存字节数</p>
</li>
<li><p>zltail （unit32_t）</p>
<p>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过该偏移量可以无需遍历整个压缩列表就可以确定表尾节点的地址</p>
</li>
<li><p>zllen （unit16_t）</p>
<p>记录压缩列表包含的节点数量</p>
</li>
<li><p>entryX</p>
<p>压缩列表节点</p>
</li>
<li><p>zlend</p>
<p>特殊值0xFF，用于标记压缩列表的末端</p>
</li>
</ul>
<h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>quicklist结构是在redis 3.2版本中新加的数据结构，用在<strong>列表的底层实现。</strong></p>
<h5 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h5><p>quicklist是由<strong>ziplist组成的双向链表</strong>，链表中的每一个节点都以压缩列表ziplist的结构保存着数据，而ziplist有多个entry节点，保存着数据。相当与一个quicklist节点保存的是<strong>一片数据，而不再是一个数据</strong>。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>quicklist宏观上是一个双向链表，因此，它具有一个双向链表的有点，进行插入或删除操作时非常方便，虽然复杂度为O(n)，但是不需要内存的复制，提高了效率，而且访问两端元素复杂度为O(1)。</li>
<li>quicklist微观上是一片片entry节点，每一片entry节点内存连续且顺序存储，可以通过二分查找以 log2(n) 的复杂度进行定位。</li>
</ul>
<hr>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="哈希表节点-dictEntry"><a href="#哈希表节点-dictEntry" class="headerlink" title="哈希表节点 (dictEntry)"></a>哈希表节点 (dictEntry)</h4><h5 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>key (void*)</p>
</li>
<li><p>v (union{void *val,unit64_t u64,int64_t s64})</p>
<p>v可以是一个指针，unit64_t 整数或者int64_t整数</p>
</li>
<li><p>next （指向下一个节点）</p>
<p>主要是解决键冲突问题，当有冲突的时候直接将新的节点添加在表头处，也就是头插法</p>
</li>
</ul>
<h4 id="哈希表-dictht"><a href="#哈希表-dictht" class="headerlink" title="哈希表 (dictht)"></a>哈希表 (dictht)</h4><h5 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>table （dictEntry**）</p>
<p>哈希表数组，每个元素就是一个哈希表节点</p>
</li>
<li><p>size （unsigned long）</p>
<p>哈希表的大小</p>
</li>
<li><p>sizemask （unsigned long）</p>
<p>哈希表大小掩码 = size-1</p>
</li>
<li><p>used （unsigned long）</p>
<p>哈希表中已有节点的数量</p>
</li>
</ul>
<h4 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 (dict)"></a>字典 (dict)</h4><h5 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>type （dictType*）</p>
<p>指向dictType的指针，每个dictType结构包含了一组操作特定类型键值对的函数</p>
<p>比如hashFunction 计算哈希值的函数</p>
</li>
<li><p>privdata （void*）</p>
<p>保存需要传给类型特定函数的可选参数（就是dictType中的函数）</p>
</li>
<li><p>ht[2] (dicth)</p>
<p>哈希表数组</p>
<ul>
<li><p>ht[0]</p>
<p>字典使用的哈希表</p>
</li>
<li><p>ht[1]</p>
<p>留给rehash使用的 </p>
</li>
</ul>
</li>
<li><p>trehashidx</p>
<p>rehash索引，当rehash不进行时是-1</p>
</li>
</ul>
<h4 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h4><p>hash = dict-&gt;type-&gt;hashFunction(k0)</p>
<p>index = hash &amp; ht[0].sizemask</p>
<p>使用的算法是MurmurHash2，该算法的优点在于即使输入的键是有规律的，算法仍能给出一个很好的随机分布性</p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li><p>为字典的ht[1]分配空间，空间的大小取决于需要执行的操作</p>
<ul>
<li><p>扩展操作</p>
<ul>
<li><p>场景</p>
<p>负载因子 = 哈希表已保存的节点数量/哈希表的大小 = used/size</p>
<p>当服务器目前没有执行BGSAVE或者BGREWRITEAOF，并且哈希表的负载因子&gt;=1</p>
<p>or</p>
<p>当服务器正在执行BGSAVE或者BGREWRITEAOF，并且哈希表的负载因子&gt;=5</p>
</li>
<li><p>操作</p>
<p>ht[1]的大小为<strong>第一个</strong>&gt;=ht[0].used*2<sup>n</sup></p>
</li>
</ul>
</li>
<li><p>收缩操作</p>
<ul>
<li><p>场景</p>
<p>哈希表的负载因子&lt;0.1</p>
</li>
<li><p>操作</p>
<p>ht[1]的大小为<strong>第一个</strong>&gt;=ht[0].used的2<sup>n</sup></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面</p>
</li>
<li><p>当所有的ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0],将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表</p>
</li>
</ul>
<h5 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h5><p>每次对字典执行操作的时候，除了执行指定的操作还会将ht[0]上面的键值rehash到ht[1]，每次rehash后都会将rehashidx+1，当所有的rehash都已经完成了，则将rehashidx置为-1，表示rehash操作已完成</p>
<p>对于rehash期间的查找：</p>
<p>如果在ht[0]中没有找到，那么会去ht[1]中进行查找</p>
<h4 id="编码种类"><a href="#编码种类" class="headerlink" title="编码种类"></a>编码种类</h4><h5 id="种类-2"><a href="#种类-2" class="headerlink" title="种类"></a>种类</h5><ul>
<li><p>ziplist</p>
<p>它会将同一键值对的两个节点都放在一起</p>
</li>
<li><p>hashtable</p>
</li>
</ul>
<h5 id="转换-2"><a href="#转换-2" class="headerlink" title="转换"></a>转换</h5><p>当以下2个条件都满足时</p>
<ul>
<li><p>哈希对象保存的所有键值的键和值的字符串长度&lt;64字节</p>
</li>
<li><p>哈希对象保存的键值对数量&lt;512</p>
</li>
</ul>
<p>会使用ziplist编码</p>
<p>否则会使用hashtable编码</p>
<hr>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><h5 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>backward （struct zskiplistNode）</p>
<p>后退指针</p>
</li>
<li><p>score （doule）</p>
<p>分值</p>
</li>
<li><p>obj （robj *）</p>
<p>成员对象，一般主要是SDS</p>
</li>
<li><p>level[]  (struct zskiplistLevel)</p>
<p> 层</p>
<ul>
<li>forward （struct zskiplistNode） 前进指针</li>
<li>span （unsigned int）跨度</li>
</ul>
</li>
</ul>
<p>结构如图所示：</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210828100439.png" alt="在这里插入图片描述"></p>
<h5 id="对于每个节点上层的大小"><a href="#对于每个节点上层的大小" class="headerlink" title="对于每个节点上层的大小"></a>对于每个节点上层的大小</h5><p>随机生成一个介于1和32之间的值作为level数组的大小</p>
<h5 id="如何知道已经到达表的尾端"><a href="#如何知道已经到达表的尾端" class="headerlink" title="如何知道已经到达表的尾端"></a>如何知道已经到达表的尾端</h5><p>再最后一个节点中所有的层中的forward都指向null</p>
<h5 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h5><p>一般一共有32个level</p>
<h4 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h4><h5 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h5><p>跳跃表</p>
<ul>
<li><p>header</p>
<p>指向第一个节点</p>
</li>
<li><p>tail</p>
<p>指向最后一个尾节点</p>
</li>
<li><p>level</p>
<p>目前跳跃表内，层数最大的那个节点的层数（不包括头节点）</p>
</li>
<li><p>length</p>
<p>跳跃表的长度</p>
</li>
</ul>
<h5 id="跳跃表的时间复杂度"><a href="#跳跃表的时间复杂度" class="headerlink" title="跳跃表的时间复杂度"></a>跳跃表的时间复杂度</h5><p>O(logN) ~ O(N)</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="编码类型-2"><a href="#编码类型-2" class="headerlink" title="编码类型"></a>编码类型</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li><p>intset</p>
</li>
<li><p>hashtable</p>
<p>字典的每个键都是一个字符串对象，每个字符串对象为一个集合元素，字典的值都为null</p>
</li>
</ul>
<h5 id="转换-3"><a href="#转换-3" class="headerlink" title="转换"></a>转换</h5><p>当以下2个条件都满足时</p>
<ul>
<li><p>集合对象保存的所有元素为整数值</p>
</li>
<li><p>集合对象保存的元素数量&lt;512个</p>
</li>
</ul>
<p>会使用inset编码</p>
<p>否则会使用hashtable编码</p>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>有序的整数集合</p>
<h5 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>encoding (uint32_t) 编码方式</p>
<p><font color=red>该值代表了整个集合中元素的类型</font></p>
</li>
<li><p>length (uint32_t) 元素数量</p>
</li>
<li><p>contents[] (int8_t)</p>
<p>保存元素的数组，此处的int8_t并非代表的是元素的类型，真正的类型取决于encoding</p>
</li>
</ul>
<h5 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h5><ul>
<li><p>含义</p>
<p>当元素的类型都为int8时，突然增加一个int16的元素，那么整个数组中的元素都将升级为int16类型</p>
</li>
<li><p>步骤</p>
<ol>
<li><p>根据新元素的类型，扩展整数集合底层数组的空间大小</p>
</li>
<li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放置到正确位上，在放置元素过程中需要保持底层数组的有序性质不变</p>
</li>
<li><p>将新元素添加到底层数组中</p>
<p>对于新元素的摆放位置，因为发生了升级，要么是比现有的元素都大，要么是比现有的元素都小，插入的时间复杂度为O(1)</p>
</li>
</ol>
</li>
<li><p>当元素进行升级之后就不能再降级</p>
</li>
<li><p>升级的好处在于节约内存</p>
</li>
</ul>
<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><ul>
<li><p>创建整数集合</p>
<p><code>sadd &#123;集合名词&#125; &#123;元素...&#125;</code></p>
</li>
<li><p>查看集合类型</p>
<p><code>object encoding &#123;key&#125;</code></p>
</li>
</ul>
<hr>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><h4 id="编码类型-3"><a href="#编码类型-3" class="headerlink" title="编码类型"></a>编码类型</h4><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul>
<li><p>ziplist</p>
</li>
<li><p>skiplist</p>
<p>skiplist使用zset结构作为底层实现</p>
</li>
</ul>
<h5 id="转换-4"><a href="#转换-4" class="headerlink" title="转换"></a>转换</h5><p>当以下2个条件都满足时</p>
<ul>
<li><p>有序集合保存到所有字符串元素长度&lt;64字节</p>
</li>
<li><p>有序集合对象保存的元素数量&lt;128个</p>
</li>
</ul>
<p>会使用ziplist编码</p>
<p>否则会使用skiplist编码</p>
<h4 id="zst"><a href="#zst" class="headerlink" title="zst"></a>zst</h4><h5 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h5><ul>
<li><p>zskiplist</p>
<p>跳跃表</p>
</li>
<li><p>dict</p>
<p>字典</p>
</li>
</ul>
<h5 id="为何要同时使用skiplist和dict"><a href="#为何要同时使用skiplist和dict" class="headerlink" title="为何要同时使用skiplist和dict"></a>为何要同时使用skiplist和dict</h5><ul>
<li><p>skiplist</p>
<p>较好的执行范围型的操作，比如zrank、zrange</p>
</li>
<li><p>dict</p>
<p>对于查找操作，可以将复杂度将为O（1）</p>
</li>
</ul>
<hr>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>redis中每一个对象都是由一个redisObject结构表示</p>
<h4 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p>type (unsigned)</p>
<p>类型</p>
<p>主要包括一下几种类型：</p>
<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象</li>
<li>有序集合对象</li>
</ul>
</li>
<li><p>encoding （unsigned）</p>
<p>编码类型</p>
<ul>
<li><p>定义</p>
<p>记录了对象所使用的编码。也就是这对象使用了什么数据结构作为底层的实现</p>
<p>每种类型的对象都至少使用了2种不同的编码</p>
</li>
</ul>
</li>
<li><p>ptr （void*）</p>
<p>指向底层实现数据结构的指针</p>
</li>
<li><p>…</p>
</li>
</ul>
<h4 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h4><h5 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h5><ul>
<li>redis会对输入的命令执行类型检查操作，也就是专有的命令必须对应指定的类型</li>
</ul>
<h5 id="命令多态"><a href="#命令多态" class="headerlink" title="命令多态"></a>命令多态</h5><ul>
<li><p>类型多态</p>
<p>像del、expire、type这种可以针对任何类型使用</p>
</li>
<li><p>编码多态</p>
<p>像llen这种命令是针对指定类型的，但是这个类型下面的不同编码都可以使用该指令</p>
</li>
</ul>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>redis内部会构建一个计数器实现内存的回收</p>
<p>每个对象的引用计数信息由redisObject结构的refcount属性记录</p>
<ul>
<li>新建对象 +1</li>
<li>该对象被新程序使用 +1</li>
<li>不被一个程序使用 -1</li>
<li>=0时释放该对象占用的内存</li>
</ul>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>一般redis中只对包含整数值的字符串对象进行共享</p>
<p>对于字符串对象不会共享，因为需要检查字符串是否相等，这会极大的消耗CPU</p>
<h4 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h4><p>redisObject中包含一个lru属性，表示该对象最后一次被命令程序访问的时间</p>
<p>命令</p>
<p><code>object idletime &#123;key&#125;</code></p>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/Sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/Sentinel/" class="post-title-link" itemprop="url">哨兵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:02:01" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/Sentinel/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/Sentinel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Sentinel是检测redis集群中主从节点状态的系统</p>
<p>它不附属于主从节点，而是一个独立的系统</p>
<p>sentinel本质上是一个运行在特殊模式下的Redis服务器</p>
<h2 id="初始化Sentinel"><a href="#初始化Sentinel" class="headerlink" title="初始化Sentinel"></a>初始化Sentinel</h2><ul>
<li><p>初始化Sentinel</p>
<p>初始化一个特殊的Redis服务器，但是该服务器并不使用数据库，也就是说在初始化的时候不会去载入RDB文件或者AOF文件</p>
</li>
<li><p>使用Sentinel专用代码</p>
<p>将一部分普通Redis服务器使用的代码替换成Sentinel专用代码</p>
<p>比如说</p>
<ul>
<li>port从6379改为了26379</li>
<li>服务器的命令表也作出了限制，比如redis中的set、del等命令无法使用</li>
</ul>
</li>
<li><p>初始化Sentinel状态</p>
</li>
<li><p>初始化Sentinel状态的master属性</p>
<p>Sentinel状态中有一个master字典记录了所有被Sentinel监视的主服务器的相关信息</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210912103000.png" alt="image-20210912102952035"></p>
</li>
<li><p>创建连向主服务器的网络连接</p>
<p>Sentinel成为主服务器的客户端，它可以向主服务器发送命令，并且从命令中获取相关信息</p>
<ul>
<li><p>命令连接</p>
<p>该连接用于向主服务器发送命令，并接受命令回复</p>
</li>
<li><p>订阅连接</p>
<p>订阅主服务器的_ sentinel _:hello频道</p>
<p>主要作为主要为了通过该频道发现其他的Sentinel</p>
</li>
</ul>
</li>
</ul>
<h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>Sentinel默认以10s发送一次命令连接想被监视的主服务器发送INFO命令并接受返回信息</p>
<p>与此同时也会获取到该主服务器的从服务器的信息</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210912103541.png" alt="image-20210912103539416"></p>
<h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>当Sentinel发现主服务器有新的从服务器出现时除了会为该从服务器创建相应的实例结构之外，还会创建连接到从服务器的命令连接和订阅连接</p>
<p>创建连接之后会每10s通过命令连接想从服务器发送INFO命令</p>
<h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>默认情况下，Sentinel每2s通过命令连接想所有被监视的主从服务器的_ sentinel _:hello频道发送一条消息</p>
<h2 id="接受主服务器和从服务器的频道信息"><a href="#接受主服务器和从服务器的频道信息" class="headerlink" title="接受主服务器和从服务器的频道信息"></a>接受主服务器和从服务器的频道信息</h2><p>对于监视同一个服务器的多个Sentinel，一个Sentinel发送的消息会被其他Sentinel接收到，该消息会被其他Sentinel用于更新自身（自身也可以接收到自身发送的消息，但是不会对其做处理）</p>
<h3 id="更新Sentinel字典"><a href="#更新Sentinel字典" class="headerlink" title="更新Sentinel字典"></a>更新Sentinel字典</h3><p>Sentinel除了监视服务器之外，还会对其他监视同一个服务器的Sentinel进行监视，与此同时会在master结构中创建sentinel字典进行保存</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210912104647.png" alt="image-20210912104645401"></p>
<h3 id="创建连向其他Sentinel的命令连接"><a href="#创建连向其他Sentinel的命令连接" class="headerlink" title="创建连向其他Sentinel的命令连接"></a>创建连向其他Sentinel的命令连接</h3><p>当Sentinel通过频道信息发现了新的Sentinel会对其创建一个命令连接，新的Sentinel同样也会创建新的命令连接到发现它的Sentinel，这样会形成一个网络</p>
<h2 id="检测主观下线（单个Sentinel自己的监测）"><a href="#检测主观下线（单个Sentinel自己的监测）" class="headerlink" title="检测主观下线（单个Sentinel自己的监测）"></a>检测主观下线（单个Sentinel自己的监测）</h2><p>Sentinel会每1s向所有与它创建了命令连接的实例发送ping命令，并通过返回值来判断实例是否在线</p>
<p>有效回复</p>
<ul>
<li>+PONG</li>
<li>-LOADING</li>
<li>-MASTERDOWN</li>
</ul>
<p>除了有效恢复其他都是无效回复</p>
<p>如果在用户指定时间内（down-after-milliseconds）连续向Sentinel返回无效回复，那么Sentinel会修改该实例对应的结构</p>
<p>注意：</p>
<ul>
<li>down-after-milliseconds不仅作用于主服务器，也会作用于该服务器下的从服务器</li>
<li>多个Sentinel设置的下线时长可能不同</li>
</ul>
<h2 id="检测客观下线（多个Sentinel商议的结果）"><a href="#检测客观下线（多个Sentinel商议的结果）" class="headerlink" title="检测客观下线（多个Sentinel商议的结果）"></a>检测客观下线（多个Sentinel商议的结果）</h2><ol>
<li><p>当某一个Sentinel监测到某一个主服务器下线了，它会发送<code>Sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>给其他的Sentinel进行询问</p>
</li>
<li><p>接收到询问的Sentinel会检查是否该主服务器下线了，并进行回复</p>
<p>回复的组成内容如下</p>
<ul>
<li><p>down_state  目标服务器的下线状态</p>
</li>
<li><p>leader_runid </p>
<ul>
<li><p>*</p>
<p>仅仅检查主服务器的下线状态</p>
</li>
<li><p>目标Sentinel的局部领头Sentinel的运行ID</p>
<p>也就是该Sentinel选举的Sentinel的ID</p>
</li>
</ul>
</li>
<li><p>leader_epoch</p>
<p>当前Sentinel的局部领头Sentinel的配置纪元</p>
</li>
</ul>
</li>
<li><p>收到其他Sentinel发来的回复，1中的Sentinel会根据其他Sentinel同意的数量进行决策</p>
<ul>
<li>当数量&gt;配置指定的数量则会将1中主服务器的flags属性的SRI_O_DOWN标识打开</li>
</ul>
</li>
</ol>
<p>注意：不同Sentinel判断客观下线的条件可能不同</p>
<h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判断为客观下线时，监视这个下线服务器的各个Sentinel会进行协商，选举出领头Sentinel，并由领头Sentinel对线下主服务器进行故障转移操作</p>
<p>选举规则</p>
<ul>
<li><p>所有在线的Sentinel都有被选为领头Sentinel的资格</p>
</li>
<li><p>每个发现主服务器下线的Sentinel都会要求其他Sentinel选举自己为领头Sentinel</p>
</li>
<li><p>如果一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<code>Sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>，其中的runid如果不是*的话，表示前者要求后者将其设置为领头Sentinel。</p>
<p>因为发送这个命令的Sentinel都是发现主服务器挂机的Sentinel，因此其发送的runid只会是其自身</p>
</li>
<li><p>最先向目标Sentinel发送设置要求的源Sentinel都会成为目标Sentinel的局部领头Sentinel，之后目标Sentinel接受的所有设置要求都会被拒绝</p>
</li>
<li><p>目标Sentinel接收到<code>Sentinel is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>命令之后会回复一条目录，其中回复的leader_runid就是目标Sentinel的局部领头Sentinel的runid</p>
</li>
<li><p>如果某个Sentinel有超过半数以上的Sentinel都选他，则它会成为领头Sentinel</p>
</li>
<li><p>如果在给定时间内没有选出领头Sentinel，则会在一段时间后重新进行选举直到选出为止</p>
</li>
</ul>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>选举出的领头Sentinel会对已下线的主服务器执行故障转移操作</p>
<ol>
<li>在已下线主服务器属下的所有从服务器中挑选出一个从服务器，并将其转为主服务器</li>
<li>让已下线的主服务器的所有从服务器改为复制新的主服务器</li>
<li>让已下线的主服务器设置为新主服务器的从服务器，当这个旧主服务器重新上线后会成为新主服务器的从服务器</li>
</ol>
<h3 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h3><p>选出规则</p>
<ul>
<li><p>删除所有处于下线或者断线状态的从服务器</p>
</li>
<li><p>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器</p>
</li>
<li><p>删除所有与已下线主服务连接断开超过down-after-milliseconds*10毫秒的从服务器。保留保存数据比较新的服务器</p>
</li>
<li><p>根据从服务器的优先级</p>
</li>
<li><p>根据从服务器的复制偏移量</p>
</li>
<li><p>根据RunId，选择runid最小的从服务器</p>
</li>
</ul>
<p>最后领头Sentinel向选中服务器发送SLAVOF no one 命令，通过Info命令确认选出的从服务器已经升级为主服务器</p>
<h3 id="修改从服务器的复制目标和将旧的主服务器变为从服务器"><a href="#修改从服务器的复制目标和将旧的主服务器变为从服务器" class="headerlink" title="修改从服务器的复制目标和将旧的主服务器变为从服务器"></a>修改从服务器的复制目标和将旧的主服务器变为从服务器</h3><p>领头Sentinel使用slave of命令实现</p>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/AOF%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/AOF%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">AOF持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:01:13" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/AOF%E6%8C%81%E4%B9%85%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/AOF%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>AOF是通过保存Redis服务器所执行的写命令来记录数据库状态的，被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</p>
<h3 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h3><p>Redis服务器进程中存在一个事件循环，负责接收客户端的命令请求，服务器每次结束一个事件循环之前都会调用flushAppedOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。</p>
<p>保存的条件由服务器的appendfsync选项的值来确定</p>
<ul>
<li><p>always</p>
<p>将aof_buf缓冲区中的所有内容写入并同步到AOF文件中</p>
</li>
<li><p>everysec （Redis默认选项）</p>
<p>如果距离上一次AOF写入的事件距离现在超过1s，那么再次对AOF文件进行同步</p>
</li>
<li><p>只负责将aof_buf缓冲区中的内容写入到AOF文件中，但并不会对AOF文件进行同步，何时同步将有操作系统决定</p>
</li>
</ul>
<h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>创建一个不带网络连接的伪客户端</li>
<li>从AOF文件中分析并读取一条写命令</li>
<li>使用伪客户端执行被读出的写命令</li>
<li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕</li>
</ol>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>原理：将原来对一个键值的多个指令变成一个指令</p>
<p>当AOF不断写了之后会导致内部的AOF文件不断扩大，从而导致整个文件体积太大，因此需要对AOF进行重写。</p>
<p><font color=red>AOF重写不是读取AOF文件，而是直接读取Redis中的内容，这样就可以读取最终状态</font></p>
<p>AOF重写时，当某一个键中的记录太多时会分成多个指令记录来写，比如说某一个键里面有128个值（默认最大是64个），那么会分成两次来进行记录</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><ul>
<li><p>出现问题</p>
<p>当子进程进行文件重写时，数据库中只有k1一个键，但是当子进程完成AOF文件重写之后，服务器进程的数据库中已经新设置了k2,k3,k4三个键，因此重写后的AOF文件和服务器当前的数据库状态并不一致，新的AOF文件中只有k1，但是数据库实际上却有了k1,k2,k3,k4这四个键</p>
<p><strong>此处采用子进程是为方便了父子进程共享内存中的数据，避免了加锁和内存的消耗</strong></p>
</li>
<li><p>解决方法</p>
<p>为了解决数据不一致的问题，会先将AOF的内容写入到<strong>AOF重写缓冲区</strong></p>
<p><font color=red>这里的AOF缓冲区是为普通的AOF文件准备的，而AOF重写缓冲区是为了AOF重写准备的，因为AOF重写只有在一定的条件下才会触发，因此不需要担心AOF缓冲区没有用</font></p>
<p>步骤</p>
<ol>
<li>执行客户端发来的命令</li>
<li>将执行后的写命令追加到AOF缓冲区</li>
<li>将执行后的写命令追加到AOF重写缓冲区</li>
</ol>
</li>
<li><p>当子进程完成重写工作之后，它会发送信号给父进程，父进程会调用一个信号处理函数，并执行以下工作</p>
<ol>
<li>将AOF重写缓冲区的所有内容写入到新的AOF文件中</li>
<li>对新的AOF进行改名，原子的覆盖现有的AOF文件，完成AOF文件的替换</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E7%9B%91%E8%A7%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E7%9B%91%E8%A7%86%E5%99%A8/" class="post-title-link" itemprop="url">监视器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:02:11" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E7%9B%91%E8%A7%86%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E7%9B%91%E8%A7%86%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通过执行monitor，客户端可以将自己变成一个监视器，实时接收打印服务器当前处理的命令请求的相关信息</p>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">慢查询日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：12:00:47" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>505</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h2 id="慢查询日志相关参数"><a href="#慢查询日志相关参数" class="headerlink" title="慢查询日志相关参数"></a>慢查询日志相关参数</h2><ul>
<li><p>slowlog-log-slower-than</p>
<p>指定的时间超过多少微秒会被记录到日志中</p>
<p><code>CONFIG SET slowlog-log-slower-than 0</code></p>
</li>
<li><p>slowlog-max-len</p>
<p>最多保存多少条慢查询日志</p>
<p><code>config set slow-max-len 5</code></p>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在redisServer中包含了几个和慢查询日志功能相关的属性</p>
<ul>
<li><p>slowlog_entry_id (long)</p>
<p>下一条慢查询日志的Id （每次会+1）</p>
</li>
<li><p>slowlog (list)</p>
<p>慢查询日志的链表</p>
</li>
<li><p>slowlog-log-slower-than</p>
</li>
<li><p>slowlog-max-len</p>
</li>
</ul>
<p>慢查询日志的插入是头插法，如果日志的数目大于最大的限制那么将会删除最旧的一条慢查询日志</p>
<p><font color=red>注意：如果以前没有设置慢查询日志，那么当你设置之后，如果设置之后的指令为慢查询日志的数量小于设置的最大慢查询日志的数量，那么会根据你设置的数量从现有的日志中去取出符合要求的日志。</font></p>
<p>比如我现在设置慢查询日志的要求为最大为5个日志，时间为0。那么当我设置完慢查询日志的属性之后，我又执行了两个命令，按道理来说只会存在两个日志，但是它回去原来的日志中寻找最近满足你设置慢查询要求的日志添加到其中。</p>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cooperxj.github.io/2022/01/07/redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cooper">
      <meta itemprop="description" content="记录一些学习笔记、小说、随笔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooper Notes">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">发布与订阅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-07 08:43:29 / 修改时间：11:59:51" itemprop="dateCreated datePublished" datetime="2022-01-07T08:43:29+08:00">2022-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/07/redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/07/redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>674</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非模式"><a href="#非模式" class="headerlink" title="非模式"></a>非模式</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><ul>
<li><p>命令</p>
<p><code>subscribe &lt;channel...&gt;</code></p>
</li>
<li><p>原理</p>
<p>redis将所有频道的订阅都保存在服务器状态的pubsub_channels字典里面</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210915095231.png" alt="image-20210915095229962"></p>
<p>每次订阅一个新的频道就先创建一个键并在该键的链表的末尾加上该频道</p>
<p>如果订阅的频道已经存在那么就直接将其放到链表的末尾</p>
</li>
</ul>
<h3 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h3><p>将对应键指向的链表中的对应项删除</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="订阅-1"><a href="#订阅-1" class="headerlink" title="订阅"></a>订阅</h3><ul>
<li><p>命令</p>
<p><code>PSUBSCRIBE &lt;patterns...&gt;</code></p>
</li>
<li><p>原理</p>
<p>redis将所有模式的订阅存放在服务器状态的pubsub_patterns属性里面</p>
<p><img src="https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20210915095735.png" alt="image-20210915095734875"></p>
</li>
</ul>
<p>每次新增一个模式订阅则添加到链表末尾</p>
<h3 id="退订-1"><a href="#退订-1" class="headerlink" title="退订"></a>退订</h3><p>删除链表中对应的项</p>
<p><font color=red>注意：假设客户端同时订阅了某种模式和符合该模式的某个频道，那么发送给这个频道的消息将被客户端接收到两次，只不过这两条消息的类型不同，一个是message类型，一个是pmessage类型，但其内容相同。</font></p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><h3 id="非模式-1"><a href="#非模式-1" class="headerlink" title="非模式"></a>非模式</h3><p>先在<code>pubsub_channels</code>中找到订阅者的链表，然后将消息发送给该链表上的所有客户端</p>
<h3 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h3><p>先在<code>pubsub_channels</code>遍历找到所有与channel匹配的模式的订阅者，然后发送给这些模式的订阅者</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li><p><code>pubsub channels &lt;patterns&gt;</code></p>
<ul>
<li><p>如果不给定patterns参数</p>
<p>返回当前服务器上所有被订阅的频道（只包含pubsub_channels中的频道）</p>
</li>
<li><p>如果给了patterns参数</p>
<p>返回符合当前patterns的频道</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>pubsub numsub &lt;channels&gt;</code></p>
<p>返回channels（可以指定多个）的订阅者的数量</p>
</li>
<li><p><code>pubsub numpat</code></p>
<p>返回<code>pubsub_patterns</code>中的数量</p>
</li>
</ul>

      
    </div>

    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cooper</p>
  <div class="site-description" itemprop="description">记录一些学习笔记、小说、随笔</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">341</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">75</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CooperXJ" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CooperXJ" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1789023580@qq.com" title="E-Mail → mailto:1789023580@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cooper</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">648k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:49</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'rOzi1T6uncSYNdx0tp1owOzV-gzGzoHsz',
      appKey     : 'Fk3s6CQBK042e1QltClHnTBP',
      placeholder: "留下邮箱，有回复时你将收到提醒，邮箱不会被公开",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
